# sql-learning in week12(using MySQL)
<h2>变量、存储过程与结构和流程控制结构</h2>
<h3>变量</h3>
变量的分类：
<ul>
	<li>系统变量
		<ol>
			<li>全局变量</li>
			<li>回话变量</li>
		</ol>
	</li>
	<li>自定义变量
		<ol>
			<li>用户变量</li>
			<li>局部变量</li>
		</ol>
	</li>
</ul>
<h4>系统变量</h4>
说明：变量由系统提供，不是用户定义，属于服务器层变。<br>
使用语法：

```mysql
#查看所有全局系统变量
SHOW GLOBAL VARIABLES;

#查看满足某条件部分系统变量
SHOW GLOBAL VARIABLES LIKE "%char%";
#这里查看了满足带有字符串char的变量

#查看指定的某个系统变量的值，查看会话变量时可以省略session
SELECT @@global.变量名;

#为某个系统变量赋值，给会话变量赋值时session可省略
#方式1：
SET global 变量名 = 值;
#方式2：
SET @@global 变量名 = 值;
```
<br>
如果是全局级别，需要加global，如果是会话级别，需要加session，不写默认session。
<h4>会话变量</h4>
作用域：仅仅针对于当前会话（链接）有效

```mysql
#查看所有的会话变量
SHOW [SESSION] VARIABLES;

#查看满足某条件部分会话变量
SHOW [session] VARIABLES LIKE "%char%";
#这里查看了满足带有字符串char的变量

#查看指定的某个会话变量的值，查看会话变量时可以省略session
SELECT @@[session].变量名;

#为某个会话变量赋值，给会话变量赋值时session可省略
#方式1：
SET [session] 变量名 = 值;
#方式2：
SET @@[session] 变量名 = 值;
```
<br>
<h4>自定义变量——用户变量</h4>
说明：用户自定义的变量，不是系统的。<br>
使用步骤：声明->赋值->使用<br>
作用域：针对于当前会话（链接）有效，同于会话变量的作用域<br>

```mysql
#声明并初始化
SET @用户变量名 = 值;
SET @用户变量名 := 值;
SELECT @用户变量名 := 值;

#赋值
#方式1：
SET @用户变量名 = 值;
SET @用户变量名 := 值;
SELECT @用户变量名 := 值;
#方式2：
SELECT 字段 INTO 变量名 FROM 表;

#查看用户变量的值
SELECT @用户变量名; 
```
<br>
<h4>自定义变量——局部变量</h4>
说明：用户自定义的变量，不是系统的。<br>
使用步骤：声明->赋值->使用<br>
作用域：仅仅在定义他的begin end中有效。<br>
应用在begin end中的第一句话<br>

```mysql
#声明并初始化
DECLARE 变量名 类型;
DECLARE 变量名 类型 DEFAULT 值;

#赋值
#方式1：
SET 局部变量名 = 值;
SET 局部变量名 := 值;
SELECT @局部变量名 := 值;
#方式2：
SELECT 字段 INTO 变量名 FROM 表;

#查看局部变量的值
SELECT 局部变量名; 
```
<br>
<table>
	<tr>
		<td></td>
		<td>作用域</td>
		<td>定义和使用的位置</td>
		<td>语法</td>
	</tr>
	<tr>
		<td>用户变量</td>
		<td>当前会话</td>
		<td>会话中的任何地方</td>
		<td>必须加@，不用限定类型</td>
	</tr>
	<tr>
		<td>局部变量</td>
		<td>begin end中</td>
		<td>只能在begin end中并且必须为第一句话</td>
		<td>一般不加@（除了select），需要限定类型</td>
	</tr>
</table>
<h3>存储过程与函数</h3>
<h4>存储过程</h4>
定义：一组预先编译好的SQL语句的集合，理解或批处理语句<br>
好处：
<ol>
	<li>提高代码的重用性</li>
	<li>简化操作</li>
	<li>减少了编译次数，并且减少了和数据库服务器的连接次数，提高了效率</li>
</ol>
语法：

```mysql
#创建
CREATE PROCEDURE 存储过程名(参数列表)
BEGIN
		存储过程体
END
#注意：
#1.参数列表包含三部分：参数模式 参数名 参数类型
#如：IN stuId INT
#2.存储过程体只有一句话的话BEGIN END可以省略
#3.存储过程中每条语句的结尾都要加分号
#4.存储过程的结尾可以用DELIMITER设置结束符号

#参数模式分三种IN、OUT、INOUT
#IN：该参数可以作为输入
#OUT：该参数可以作为输出（返回值）
#INOUT：该参数可以输入也可以作为输出（返回值）


#调用
CALL 存储过程名(实参列表);
```
<br>
实例：

```mysql
#插入到admin表中1条记录
DELIMITER $
CREATE PROCEDURE myp4()
BEGIN
	INSERT INTO admin(username,`PASSWORD`) VALUES('a','2');
END $
CALL myp4();

#创建带IN模式参数的存储过程(一个参数)
DELIMITER $
CREATE PROCEDURE myp5(IN userName varchar(20))
BEGIN
	INSERT INTO admin(username) VALUES(userName);
END $
CALL myp5('c');

#创建带IN模式参数的存储过程(多个参数)
DELIMITER $
CREATE PROCEDURE myp6(IN userName VARCHAR(20),IN password_ VARCHAR(20))
BEGIN
	DECLARE result INT DEFAULT 0; 		#声明并初始化
	SELECT COUNT(*) INTO result    		#赋值
	FROM admin
	WHERE username = userName AND `password` = password_;
	SELECT IF(result > 0,'success','fail'); #使用
END $
CALL myp6('a','1');

#创建带OUT模式参数的存储过程(一个参数)
DELIMITER $
CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))
BEGIN
	SELECT bo.boyName  		
	FROM boys bo
	INNER JOIN beauty  b
	ON  b.boyfriend_id = bo.id
	WHERE beautyName = b.name;
END $
CALL myp7('热巴',@boyName);
SELECT @boyName;

#创建带OUT模式参数的存储过程(多个参数)
DELIMITER $
CREATE PROCEDURE myp8(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT userCP INT)
BEGIN
	SELECT bo.boyName,bo.userCP INTO boyName,userCP 
	FROM boys bo
	INNER JOIN beauty  b
	ON  b.boyfriend_id = bo.id
	WHERE beautyName = b.name;
END $
CALL myp8('热巴',@boyName,@userCP);
SELECT @boyName,@userCP;

#创建带INOUT模式参数的存储过程(一个参数)
#例：传入a，b两个值，返回他们都翻倍的值
DELIMITER $
CREATE PROCEDURE myp10(INOUT A INT,INOUT B INT)
BEGIN
	SET A = 2 * A;
	SET B = 2 * B;
END $
SET @a = 1;
SET @b = 2;
CALL myp10(@a,@b);
SELECT @a,@b;
```
<br>
存储过程的其他操作：

```mysql
#存储过程的删除（一次只能删除一个）
DROP PROCEDURE 存储过程名;

#查看存储过程的信息
SHOW CREATE PROCEDURE 存储过程名;
```
<br>
<h4>函数</h4>
定义：一组预先编译好的SQL语句的集合，理解或批处理语句<br>
好处：
<ol>
	<li>提高代码的重用性</li>
	<li>简化操作</li>
	<li>减少了编译次数，并且减少了和数据库服务器的连接次数，提高了效率</li>
</ol>
与存储过程的区别：函数必须有且仅有一个返回。<br>
语法：

```mysql
#创建
CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型
BEGIN
		函数体
END
#1.参数列表包含两部分：参数名 参数类型
#2.函数体肯定会有return语句，如果没有则会报错
#3.函数体仅有一句话时可以省略BEGIN END
#4.函数体的结尾可以用DELIMITER设置结束符号

#调用
SELECT 函数名(参数列表);
```
<br>
实例：

```mysql
#mysql8.0版本要使用函数必须要开启函数功能
SET GLOBAL log_bin_trust_function_creators = 1;

#无参有返回
DELIMITER $
CREATE FUNCTION myp() RETURNS INT
BEGIN
	DECLARE result INT DEFAULT 0;
	SELECT COUNT(*) INTO result
	FROM employees;
	RETURN result;
END $
SELECT myp();

#有参有返回
DELIMITER $
CREATE FUNCTION myp1(empName VARCHAR(20)) RETURNS INT
BEGIN
	DECLARE result INT DEFAULT 0;
	SELECT salary INTO result
	FROM employees e
	WHERE e.last_name = empName;
	RETURN result;
END $
SELECT myp1('Kochhar');

#查看函数定义
SHOW CREATE FUNCTION 函数名;
#函数删除
DROP FUNCTION 函数名;
```
<br>
<h3>流程控制结构</h3>
分类：
<ol>
	<li>顺序结构：程序从上往下依次运行</li>
	<li>分支结构：程序从两条或多条路径选择一条去执行</li>
	<li>循环结构：程序在满足一定条件的基础上重复执行一段代码</li>
</ol>
<h4>分支结构</h4>
<h5>if函数</h5>
实现简单的双分支<br>

```mysql
#语法
IF(表达式1,表达式2,表达式3);
```
<br>
执行顺序：<br>
表达式1成立则表达式2，否则表达式3<br>
应用：任何地方
<h5>case结构</h5>
应用1：类似switch，一般用于实现等值判断。<br>
应用2：类似多重IF，一般用于实现区间判断。<br>

```mysql
#方法一：实现switch case
CASE 要判断字段或表达式
WHEN 常量1 THEN 值或语句        #语句要分号，值不用
....
ELSE 要显示的值或语句
END CASE;

#方法二： 类似于多重if
CASE
WHEN 条件1 THEN 显示的值或语句   #语句要分号值不用
...
ELSE 要显示的值或语句
END CASE;
```
<br>
特点：可以作为表达式，嵌套在其他语句中，可以放在任何地方（BEGIN END中或BEGIN END外），也可以作为独立的语句去使用（只能放在BEGIN END中）<br>
<strong>注意：当WHEN中的条件满足或成立，则执行THEN后面的语句，并且结束CASE，如果都不满足，执行ELSE。</strong>
<strong>注意：如果省略ELSE并且所有WHEN条件都不满足，则返回NULL</strong>
<h5>if结构（只能应用在BEGIN END中）</h5>
实现多重分支

```mysql
#语法：
IF 条件1 THEN 语句1；
ELSEIF 条件2 THEN 语句2;
...
ELSE 语句;
ENDIF;
#应用在BEGIN END中

#实例：
DELIMITER $
CREATE FUNCTION test(score INT) RETURNS CHAR
BEGIN
	IF score >= 90 AND score <= 100 THEN RETURN 'A';
	ELSEIF score >= 80 THEN RETURN 'B';
	ELSEIF score >= 60 THEN RETURN 'C';
	ELSE RETURN 'D';
	END IF;
END $
```
<br>
<h4>循环结构</h4>
分类：while、loop、repeat<br>
循环控制：
<ol>
	<li>iterate（类似于continue，结束本次循环，进入下一次）</li>
	<li>leave（类似于break，结束当前所在循环）</li>
</ol>
<h5>while</h5>
需要使用循环控制的话需要添加标签，否则可以不用
基本格式：

```mysql
#while语法：
[标签:] WHILE 循环条件 do
	循环体;
END WHILE [标签];

#loop语法：
[标签:] LOOP 
		循环体;
END LOOP [标签]

#repeat语法：
[标签:] REPEAT
		循环体;
UNTIL 结束循环条件
END REPEAT [标签];
```
<br>
实例：

```mysql
#while语句使用
DELIMITER $
CREATE PROCEDURE pro(IN insert_ INT)
BEGIN
	DECLARE i INT DEFAULT 0;
	WHILE i < insert_ DO
		INSERT INTO admin(username,`password`) VALUES(CONCAT('a',i),'123');
		SET i = i + 1;
	END WHILE;
END $
CALL pro(3);

#leave使用
#例：添加小于7
DELIMITER $
CREATE PROCEDURE pro(IN insert_ INT)
BEGIN
	DECLARE i INT DEFAULT 0;
	a:WHILE i < insert_ DO    #起名
		INSERT INTO admin(username,`password`) VALUES(CONCAT('a',i),'123');
		IF i >= 5 THEN LEAVE a;  #使用leave
		END IF;
		SET i = i + 1;
	END WHILE a;       
END $
CALL pro(7);

#iterate使用
#例：偶数则添加
DELIMITER $
CREATE PROCEDURE pro(IN insert_ INT)
BEGIN
	DECLARE i INT DEFAULT 0;
	a:WHILE i < insert_ DO
		SET i = i + 1;
		IF i % 2 != 0 THEN ITERATE a;
		END IF;
		INSERT INTO admin(username,`password`) VALUES(CONCAT('a',i),'123');
	END WHILE a;
END $
CALL pro(7);
```
<br>

