# sql-learning in week6(using MySQL)
<h2>分组函数</h2>
用做统计，又称为聚合函数，统计函数，组函数
<ol>
	<li>sum（求和）</li>
	<li>avg（平均值）</li>
	<li>max/min（最大最小值）</li>
	<li>count（计算个数，除去NULL）</li>
</ol>
<h3>简单使用法</h3>
如图所示：
<img src="https://github.com/SaltyFishy/sql-language/blob/week6/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.jpg" alt="简单实用">
<h3>参数支持类型</h3>
<ul>
	<li>sum、avg支持：数值型参数</li>
	<li>max、min、count可支持任何参数</li>
</ul>
<h3>NULL值处理</h3>
<ul>
	<li>sum、avg、max、min都忽略了NULL</li>
	<li>count本身就不计算NULL，NULL自然忽略</li>
</ul>
<h3>与distinct搭配实现去重运算</h3>
所有分组函数都支持。
<img src="https://github.com/SaltyFishy/sql-language/blob/week6/distinct%E6%90%AD%E9%85%8D.jpg" alt="distinct搭配">
<h3>count函数详解</h3>
一般说来，count函数是这么使用的：<br>
<img src="https://github.com/SaltyFishy/sql-language/blob/week6/count%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95.jpg" alt="count常规用法"><br>
但是，根据count函数的特性，它又延伸出了几种特别的使用法：<br>
<ul>
	<li>
	统计行数count（*）：<br>
	<img src="https://github.com/SaltyFishy/sql-language/blob/week6/%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0.jpg" alt="统计行数"><br>
	那么，问题来了，它是如何计算出行数为107的呢？<br>
	我们参考这个图：(好吧确实图有点丑==)<br>
	<img src="https://github.com/SaltyFishy/sql-language/blob/week6/count%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0%E8%AF%A6%E8%A7%A3.jpg" alt="count(*)统计行数详解">
	上面我们可以看到第三行、第六行跟第十二行都存在NULL值，而count(*)的计数会忽略NULL值，假如第一列有15行，由于第三行为NULL，统计结果为14行，而当统计到后面的列时，由于第二列第三行不为NULL，所以会在第一列14行的基础上+1，以此类推。<br>
	这样想的话，很自然就会想到如果某一行全为NULL怎么办？但是在mysql中有如下规定：<br>
	<strong>主键不得全为NULL</strong><br>
	于是这种情况就不存在了。
	</li>
	<li>
	统计行数count(常量)：<br>
	<img src="https://github.com/SaltyFishy/sql-language/blob/week6/%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B02.jpg" alt="统计行数2"><br>
	它的运作机理为：<br>
	<img src="https://github.com/SaltyFishy/sql-language/blob/week6/count(%E5%B8%B8%E9%87%8F)%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0%E8%AF%A6%E8%A7%A3.jpg" alt="count(常量)统计行数详解"><br>
	在数据库中添加一列全为常量的列，统计该列的行数。
	</li>
</ul>
count(*)与count(常量)的效率对比：<br>
在MYISAM存储引擎下，count(*)效率更高，<br>
在INNODB存储引擎下，count(*)与count(1)效率差别不大，比count(字段)要高。
<h3>和分组函数一同查询的字段有限制</h3>
引例:<br>
<img src="https://github.com/SaltyFishy/sql-language/blob/week6/%E5%BC%95%E4%BE%8B.jpg" alt="引例"><br>
咋一看看上去没什么问题，但是仔细思考下：id的值只有一个100，这是我们期望的吗？回来思考下我们的代码，我们真正期望的是查询所有员工的id，但是他只有一个员工的id，显然是不对的。<br>
产生错误的核心原因在于：<br>
select查询，得到的结果应该为一个规则的表格（n*n），但是avg只返回了一个值，而查询employee_id返回了107行数据，产生了冲突。<br>
<strong>得出结论：与分组函数一同查询的字段只能是在group by后面的字段（group by此处暂不展开）</strong>
