# sql-learning in week8(using MySQL)
<h2>连接查询</h2>
又称为多表查询，多表连接。当我们查询的字段涉及多个表时使用。<br>
例：查询女生名字及其男友名字<br>

```mysql
SELECT `name`,boyName FROM beauty,boys;
```
<br>
	看起来好像没有问题的亚子。。F9一下。<br>
	<img src="https://github.com/SaltyFishy/sql-language/blob/week8/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BE%8B.jpg" alt="连接查询例"><br>
	等等！一个女生有这么多男朋友？！这似乎不太对。。。<br>
	以上这种现象（由于缺少有效的连接条件导致查询结果呈现集合与集合的乘积）称为笛卡尔乘积现象。<br>
	那我们该怎么解决呢？尝试性调用条件查询：<br>

```mysql
SELECT `name`,boyName FROM beauty,boys WHERE boys.id = boyfriend_id;
```
<br>
	好的，F9，然而他又报错了<br>
	<img src="https://github.com/SaltyFishy/sql-language/blob/week8/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%2B%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E4%BE%8B.jpg" alt="连接查询+条件查询例"><br>
	说人话，就是id这个字段，在两个表（boys跟beauty都有），产生了二义性，这时候我们需要用到像C++对象调用属性的类似的格式，修改一下我们的代码。<br>

```mysql
SELECT `name`,boyName FROM beauty,boys WHERE boys.id = beauty.boyfriend_id;
```
<br>
	这样就得到了正确的结果。<br>
	连接查询分类（按年代）：
	<ol>
		<li>sql92标准（mysql基本上仅仅只支持内连接）</li>
		<li>sql99标准（推荐，mysql支持内连接+外连接（左右外连接）+交叉连接）</li>
	</ol>
	按功能分类：
	<ol>
		<li>内连接
			<ol>
				<li>等值连接</li>
				<li>非等值连接</li>
				<li>自连接</li>
			</ol>
		</li>
		<li>外连接
			<ol>
				<li>左外连接</li>
				<li>右外连接</li>
				<li>全外连接(mysql不支持)</li>
			</ol>
		</li>
		<li>交叉连接</li>
	</ol>
<h3>sql92标准</h3>
<h4>等值连接</h4>
例：	查询女生名字及其男友名字

```mysql
SELECT `name`,boyName FROM beauty,boys WHERE boys.id = beauty.boyfriend_id;
```
<br>
例：查询员工名和对应的部门名

```mysql
SELECT last_name,department_name FROM employees,departments WHERE employees.department_id = departments.department_id;
```
<br>	
例：查询员工名、工种号、工种名

```mysql
SELECT last_name,employees.job_id,job_title FROM employees,jobs WHERE employees.job_id = jobs.`job_id`;
```
<br>
有些时候表名比较长，可以给表起别名<br>

```mysql
SELECT last_name,e.job_id,job_title FROM employees AS e,jobs AS j WHERE e.job_id = j.`job_id`;
```
<br>
<strong>注意：起了别名之后就不能用原表名限定</strong><br>
例：查询有奖金的员工名、部门名

```mysql
SELECT last_name,department_name FROM employees,departments WHERE employees.commission_pct IS NOT NULL AND employees.`department_id` = departments.`department_id`;
```
<br>
例：查询城市名中第二个字符为o的对应的部门名与城市名

```mysql
SELECT department_name,city FROM locations,departments WHERE locations.location_id = departments.location_id AND locations.city LIKE "_o%";
```
<br>
	<strong>由此发现可以加筛选条件</strong><br>
例：查询每个城市的部门个数

```mysql
SELECT COUNT(*),city FROM locations,departments WHERE locations.location_id = departments.location_id GROUP BY city;
```
<br>
例：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资

```mysql
SELECT d.department_name,d.manager_id,MIN(salary) FROM departments d,employees e WHERE e.`department_id` = d.`department_id` AND e.commission_pct IS NOT NULL GROUP BY d.department_name;
```
<br>
	<strong>由此发现可以加分组条件</strong><br>
例：查询每个工种的工种名和员工的个数，按员工个数降序

```mysql
SELECT COUNT(*),job_title FROM employees e,jobs j WHERE j.`job_id` = e.`job_id` GROUP BY j.job_title ORDER BY COUNT(*) DESC;
```
<br>
	<strong>由此发现可以加排序条件</strong><br>
例：查询员工名，部门名和所在城市

```mysql
SELECT last_name,department_name,city FROM employees e,departments d,locations l WHERE e.`department_id` = d.`department_id` AND d.`location_id` = l.`location_id`;
```
<br>
	<strong>由此发现可以多表查询</strong><br>
特点总结：
<ul>
	<li>多表等值链接的结果为多表的交集</li>
	<li>n表连接至少需要n-1个连接条件</li>
	<li>多表的顺序没有要求</li>
	<li>一般需要为表起别名</li>
	<li>可以搭配诸如排序、分组、筛选子句使用</li>
</ul>
<h4>非等值连接</h4>
例：查询员工的工资和工资级别

```mysql
SELECT salary,grade_level FROM employees,job_grades WHERE salary BETWEEN lowest_sal AND highest_sal;
```
<br>
	可以添加排序、筛选
<h4>自连接（对单个表的操作）</h4>
自连接的操作是对单个表自身的字段进行连接，或者说把一张表当成两张、甚至更多张表。
例：员工名及其上级的名称<br>
执行顺序：注意我们的employees表内部有manager id跟emoloyee id两个字段，在这里自连接的操作实际上就是先利用manager id，生成一个员工表，再利用employee id生成一个领导表，（这样就实现了一个表生成多个表）再利用员工表的manager id = 领导表的employee id这一条件实现连接。<br>
<img src="https://github.com/SaltyFishy/sql-language/blob/week8/%E5%91%98%E5%B7%A5%E8%A1%A8%E4%B8%8E%E9%A2%86%E5%AF%BC%E8%A1%A8.jpg" alt="员工表与领导表">

```mysql
SELECT e1.last_name AS employee,e1.employee_id,e2.employee_id,e2.last_name AS manager 
FROM employees e1,employees e2 WHERE e1.manager_id = e2.employee_id;
```
<br>
<h3>sql99标准</h3>
标准格式:<br>

```mysql
select  查询列表
from 表1 别名 [连接类型]
join 表2 别名 on语法 [连接条件]
[where 筛选条件]
[group by 分组条件]
[having 筛选条件]
[order by 排序列表]
```
<br>
sql99标准极其连接类型
<ol>
	<li>内连接(包括等值，非等值，自连接) inner</li>
	<li>外连接（左left outer 右right outer 全外full outer，但mysql不支持全外连接）</li>
	<li>交叉连接 cross</li>
</ol>
<h4>等值连接</h4>
例1：查询员工名部门名

```mysql
SELECT last_name,department_name
FROM employees e
INNER JOIN departments d
ON e.`department_id` = d.`department_id`;
```
<br>
例2：查询名字中包含e的员工名和工种名（筛选）

```mysql
SELECT last_name,job_title
FROM employees e
INNER JOIN jobs j
ON e.`job_id` = j.`job_id`
WHERE last_name LIKE "%e%";
```
<br>
例3：查询部门个数大于三的城市名称和部门个数（分组+筛选）

```mysql
SELECT l.city,COUNT(*)
FROM locations 
INNER JOIN departments d
ON l.`location_id` = d.`location_id`
GROUP BY l.city
HAVING COUNT(*) > 3;
```
<br>
例4：查询哪个部门的部门员工个数大于3的部门名和员工个数，并按个数降序（排序）

```mysql
SELECT department_name,COUNT(*)
FROM departments d
INNER JOIN employees e
ON e.`department_id` = d.`department_id`
GROUP BY d.department_name
HAVING COUNT(*) > 3
ORDER BY COUNT(*) DESC;
```
<br>
例5：查询员工名、部门名、工种名，并按部门名降序

```mysql
SELECT job_title,department_name,last_name
FROM employees e
INNER JOIN departments d ON e.`department_id` = d.department_id
INNER JOIN jobs j ON e.`job_id` = j.`job_id`
ORDER BY department_name DESC;
```
<br>
<h4>非等值连接</h4>
例：查询员工的工资级别

```mysql
SELECT salary,grade_level
FROM employees e
INNER JOIN job_grades j
ON e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal`;
```
<br>
<h4>自连接</h4>
例：员工的名字及其上级的名字

```mysql
SELECT e1.last_name,e2.last_name
FROM employees e1
INNER JOIN employees e2 ON e1.`manager_id` = e2.`employee_id`;
```
<br>
<h4>注意事项
<strong>注意，一般两表链接不需要在意from跟inner join的两个表的先后顺序但是多个表的时候要特别在意，需要保证前面的表所生成的表与后面的表存在可用的连接条件（n个表连接至少需要n-1个连接条件）</strong>
<ul>
	<li>可以添加排序分组筛选</li>
	<li>inner可以省略</li>
	<li>筛选条件在where后，链接条件在on后，实现了分离</li>
	<li>inner join连接和sql92中的等值连接效果相同，都是查询多个表的交集</li>
</ul>
</h4>
<h4>外连接</h4>
应用场景：查询一个表中有，另一个表中没有的记录<br>
特点：
<ol>
	<li>外链接的查询结果为主表的所有记录，如果表中有和他匹配的，则显示匹配的结果，没有匹配的显示为NULL，即：外链接的查询结果为内连接结果+主表中有的而从表没有的记录</li>
	<li>左外连接，左边的为主表，右外则右边的为主表</li>
	<li>交换左右外的表的顺序，可以实现相同效果</li>
</ol>
查询女生们的配对情况
左外连接：

```mysql
SELECT b.name
FROM beauty b
LEFT OUTER JOIN boys bo ON b.boyfriend_id = bo.id;
```
<br>
查询没有男朋友的女生名：

```mysql
SELECT b.name
FROM beauty b
LEFT OUTER JOIN boys bo ON b.boyfriend_id = bo.id
WHERE bo.id IS NULL;
```
<br>
右外连接：

```mysql
SELECT b.name,bo.*
FROM boys bo
RIGHT OUTER JOIN beauty b ON b.boyfriend_id = bo.id;
```
<br>
例1：哪个部门没有员工
左外：

```mysql
SELECT department_name
FROM departments d
LEFT OUTER JOIN employees e
ON d.`department_id` = e.`department_id`
WHERE e.`employee_id` IS NULL;
```
<br>
右外：

```mysql
SELECT department_name
FROM employees e
RIGHT OUTER JOIN departments d
ON d.`department_id` = e.`department_id`
WHERE e.`employee_id` IS NULL;
```
<br>
<h4>交叉连接</h4>
相当于sql92中的笛卡尔乘积
如：

```mysql
SELECT b.name,bo.*
FROM beauty b
CROSS JOIN boys bo;
```
<br>
其中beauty12行，boys4行，结果输出48行。
<h3>总结</h3>
sql99可读性强于sql92，实现了筛选条件与连接条件的分离，且sql99支持更多功能，推荐使用sql99标准
<img src="https://github.com/SaltyFishy/sql-language/blob/week8/%E5%B7%A6%E5%A4%96%20%E5%86%85%E8%BF%9E%E6%8E%A5%20%E5%8F%B3%E5%A4%96.jpg" alt="左外 内连接 右外">
<img src="https://github.com/SaltyFishy/sql-language/blob/week8/%E5%88%A0%E9%99%A4%E4%BA%A4%E9%9B%86.jpg" alt="删除交集">
<img src="https://github.com/SaltyFishy/sql-language/blob/week8/%E5%85%A8%E5%A4%96%E5%8F%8A%E5%88%A0%E9%99%A4%E4%BA%A4%E9%9B%86.jpg" alt="全外及删除交集">







