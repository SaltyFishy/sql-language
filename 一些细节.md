# 一些细节

## 分组（group by）

我们常常都会用到分组，但是分组有个很容易让人产生困惑的点。

比如：我们想按照员工的部门查询各个部门下员工的salary

```mysql
SELECT department_id,salary
FROM employees
GROUP BY department_id;
```

返回了12行结果

<img src="https://github.com/SaltyFishy/sql-language/blob/week13/结果.png" alt="结果">

再回来看这个代码，他将我们的员工按照部门分组，但是问题来了，一个部门下可以有多个员工，那么输出的这个salary是哪个员工的salary？是随机吗？而且还有一个问题，为什么会只有12行工资，而不是全部员工的工资？

这就要引入一个点：group by会将我们的表按照字段进行分组，**但是！很重要的一点是，分组后有多少组，那么结果集至多不会超过组数（比如这里我们有12个不同的部门，那么我们的查询结果就至多只有12行），这是因为group by只会显示每组的第一条记录（比如我们例子里面输出的工资，就是对应的临时表里面顺序在最前面的那个员工的工资）**

**因此，分组group by一般不单独使用，一般都是配合聚合函数使用**

## 结束死循环

1.查看进程

```mysql
SHOW PROCESSLIST;
```

2.杀死对应进程

```mysql
KILL 线程名;
```

## 创建索引

`CREATE [UNIQUE/...] INDEX 索引名 ON 表名(列名);`

或

`ALTER TABLE 表名 ADD [UNIQUE] INDEX 索引名（列名）`

## 强制索引

例题：< a href="[针对上面的salaries表emp_no字段创建索引idx_emp_no_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/f9fa9dc1a1fc4130b08e26c22c7a1e5f?tpId=82&&tqId=29807&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking)" alt="">

**注意索引名必须要加上括号**

语法：`SELECT * FROM 表名 FORCE INDEX (索引名) WHERE ...`

注意点：**force index要紧跟from后面，写在where语句之前，否则会报错**

## 构造触发器

触发器是与MySQL数据表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。



## 窗口函数

